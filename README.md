# Programmers.2017_KAKAOCODE_prestage_Java_KakaoFriendsColoringBook

## 프로그래머스 2017 카카오코드 예선 > 카카오프렌즈컬러링북

### 1. 문제설명
input으로 가로 n, 세로 m, 색깔 int[][] picture가 그림의 정보로 들어온다. 0은 색깔이 없음을 뜻하며 인접한 색으로 칠한 영영의 개수, 가장 큰 영역의 넓이를 return하는 문제이다.

### 2. 풀이
인접한 색깔의 영역을 찾는 과정에서 stack을 이용한 DFS방식을 이용했다. 모든 픽셀을 검사하며 검사의 유무를 체크하기위한 ```boolean[][] visit```을 만들어 이미 검사를 마친 픽셀은 검사하지 않는다. 

한 픽셀에 대해 검사를 진행할 때 인접한 상, 하, 좌, 우 픽셀들을 검사하게 된다. 이때 참조할 index가 picture의 크기를 넘어가지 않도록 유효성 검사도 진행한다.

매 검사시 max보다 검사 영역의 크기가 크다면 max를 바꿔주며 검사한 픽셀과 색이같으며 인접한 영역의 픽셀들은 모두 visit==true 이므로 같은 영역의 픽셀에 대해 조사는 이루어 지지 않을 것이므로 영역의 크기도 1 증가시켜주어 필요한 값들을 return해준다.

### 3. 아쉬웠던 점
stack을 이용하여 DFS 알고리즘을 작성하였지만, 스택을 사용하지 않고 재귀적 함수를 이용하여 구현한 경우도 보았다. 처음 생각했었던 방법인데 시간이 더 오래 걸릴것이라 판단해 DFS를 선택했었다. 하지만 실제 런타임 시간을 비교해보니 stack을 이용할때 5배나 느리게 동작함을 확인하였다. 재귀적접근과 stack을 이용한 접근이 사용한 방법은 다르지만 결국 같은 이중for문을 통한 검사를 진행하기 때문에, 더 큰 자료구조를 이용한 DFS방식이 더 오래걸렸던 것 같다.
